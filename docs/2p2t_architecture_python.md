# مخطط معماري مُحدّث لتطبيق 2P2T بلغة Python

## 1) الفكرة الأساسية (بعد التعديل المطلوب)

- التطبيق يدعم **2 إلى 4 أجهزة فقط** داخل كل جلسة.
- **لا يوجد سيرفر مركزي للحسابات أو الرسائل**.
- أول اقتران بين جهازين (أو أكثر) يجب أن يتم **وجهاً لوجه وعلى نفس النطاق المحلي** (قريبين من بعض) عبر:
  - Bluetooth (يفضّل BLE)، أو
  - شبكة محلية Wi‑Fi LAN.
- أثناء الاقتران الأولي يتم تبادل:
  - مفاتيح الهوية العامة (Device Identity Keys).
  - بصمة تحقق (Safety Number / QR).
  - بيانات ثقة أولية (Trusted Device Record).
- بعد نجاح الاقتران الأولي، يمكن التواصل لاحقاً **دائماً عبر Wi‑Fi/الإنترنت** حتى لو الأجهزة في دول مختلفة، مع بقاء التشفير الطرفي الكامل.
- الجلسة تُنشأ برمز مؤقت من 6 أرقام + تحقق تشفيري، وليس كعامل أمان وحيد.
- لا تسجيل دخول، لا حسابات.
- عند إنهاء الجلسة: حذف آمن للرسائل والمفاتيح المؤقتة والوسائط.

---

## 2) اختيار تقني Python (Cross‑Platform)

## 2.1 تطبيقات العميل

- **Android**: Python عبر Kivy/Buildozer أو BeeWare (حسب استقرار الفريق).
- **Windows**: Python + Qt (PySide6) أو Toga/BeeWare.
- طبقة منطق مشتركة (Core) في Python تضم:
  - التشفير.
  - إدارة الجلسات.
  - بروتوكول الرسائل.
  - تزامن الحالة.

## 2.2 مكتبات مقترحة

- التشفير: `cryptography` (X25519, Ed25519, AES-256-GCM, HKDF).
- الصوت: `opuslib`/ربط libopus + `sounddevice` أو `pyaudio`.
- P2P عبر الإنترنت: `aiortc` (WebRTC DataChannel + صوت).
- STUN/TURN: دعم ICE عبر WebRTC.
- BLE:
  - Android عبر واجهات المنصة (bridge).
  - Windows عبر `bleak`.
- اكتشاف محلي: mDNS عبر `zeroconf`.

> ملاحظة أمنية: عملياً يُنصح باستبدال RSA‑4096 بـ X25519 + Ed25519 لأداء أفضل وPFS أقوى مع أجهزة الموبايل.

---

## 3) المعمارية الطبقية التفصيلية

## أ) طبقة الواجهة UI/UX

- شاشة إنشاء/انضمام جلسة (رمز 6 أرقام).
- شاشة الاقتران الأولي القريب:
  - بحث عن أجهزة قريبة BLE/LAN.
  - عرض بصمة التحقق (QR + رقم أمان).
  - تأكيد يدوي للطرفين.
- شاشة المحادثة:
  - رسائل نصية.
  - زر Push-to-talk للصوت.
  - حالة التشفير والاتصال (Local / Remote).
  - مؤقّت الحذف الذاتي.
- إشعارات بدون محتوى حساس.
- زر إنهاء الجلسة = مسح فوري.

## ب) طبقة الاتصال Networking

### مسار أول مرة (Mandatory Proximity Pairing)
1. Discovery قريب عبر BLE/mDNS.
2. قناة اقتران مؤقتة.
3. تبادل مفاتيح الهوية + توثيق البصمة.
4. تخزين سجل ثقة مشفر محلياً.

### المسار التشغيلي بعد الاقتران
1. محاولة اتصال مباشر LAN/Wi‑Fi أولاً.
2. عند الفشل: WebRTC P2P عبر ICE (STUN ثم TURN fallback).
3. DataChannel للرسائل النصية، وقناة صوت Opus.
4. Keepalive + إعادة اتصال تلقائي بدون كسر الجلسة.

### نقطة مهمة
- لا يعتمد الأمان على “نفس الشبكة” بعد الاقتران؛ بل على مفاتيح الثقة المتبادلة أول مرة.

## ج) طبقة التشفير Encryption

- هوية الجهاز (دائمة نسبياً):
  - `Identity Key Pair` (Ed25519 للتوقيع).
- تبادل مفاتيح الجلسة:
  - X25519 Ephemeral لكل جلسة.
  - اشتقاق مفاتيح عبر HKDF.
- تشفير الرسائل/الصوت:
  - AES-256-GCM مع `nonce` فريد لكل رسالة.
- التحقق:
  - توقيع الحزم الحرجة + عدّاد تسلسلي (Anti-Replay).
- PFS:
  - مفتاح جديد لكل جلسة + rekey دوري.

## د) طبقة البيانات Data Layer

- رسائل ووسائط داخل قاعدة مؤقتة مشفرة (SQLite مشفر أو ذاكرة فقط حسب وضع الأمان).
- مفاتيح الجلسة في الذاكرة فقط.
- حذف آمن عند إنهاء الجلسة:
  - clear buffers.
  - حذف قاعدة الجلسة.
  - إسقاط مفاتيح RAM references.
- أقل قدر ممكن من metadata.

## هـ) طبقة الحماية النظامية Hardening

- Android: تفعيل `FLAG_SECURE` ومنع النسخ الاحتياطي.
- Windows:
  - تقليل التسريب (عدم تخزين كاش حساس).
  - كشف التقاط الشاشة ليس مضمون 100%، لذلك التحذير + تعتيم المحتوى الحساس عند فقدان التركيز.
- Rate limiting + lockout مؤقت ضد brute force لرمز الجلسة.

---

## 4) بروتوكول الجلسة (مقترح مبسط)

1. المستخدم A ينشئ جلسة → يولد Session ID + PIN 6 digits.
2. المستخدم B قريب في أول مرة:
   - يكتشف A عبر BLE/LAN.
   - يتبادلان Identity Public Keys.
   - يعرضان Safety Number ويتحققان يدوياً.
3. يُنشأ Trusted Peer Record للطرفين.
4. عند أي جلسة لاحقة:
   - إدخال PIN + تحقق توقيع peer trusted key.
   - اشتقاق Session Keys جديدة (Ephemeral).
5. نقل نص/صوت مشفر E2E.
6. إنهاء/انقطاع طويل → secure wipe لبيانات الجلسة.

---

## 5) خطة تطوير عملية (Python)

## المرحلة 1: نواة التشفير والبروتوكول
- بناء Crypto Core (X25519/Ed25519/AES-GCM/HKDF).
- بناء message envelope (header, counter, signature, ciphertext).
- اختبارات وحدات للتشفير والتوقيع ومنع replay.

## المرحلة 2: الاقتران القريب لأول مرة
- BLE/mDNS discovery.
- تبادل مفاتيح + Safety Number.
- تخزين trusted peers مشفراً.

## المرحلة 3: رسائل نصية P2P
- LAN direct + WebRTC fallback.
- ACK/retry/order handling.
- مؤقت حذف تلقائي.

## المرحلة 4: الصوت المشفر
- التقاط صوت + Opus encode.
- packetization + AES-GCM.
- jitter buffer + latency monitor.

## المرحلة 5: واجهات Android/Windows
- دمج Core المشترك مع واجهتين.
- إدارة الصلاحيات (Mic/Bluetooth/Network).
- إشعارات آمنة ومنع تسريب المحتوى.

## المرحلة 6: تدقيق أمني وأداء
- Threat modeling + pentest داخلي.
- قياس استهلاك البطارية/CPU والكمون.
- تحسين rekey frequency وحجم الحزم.

---

## 6) حدود واقعية يجب الاتفاق عليها مبكراً

- عدم وجود سيرفر مركزي يعني لا مزامنة سحابية ولا استرجاع جلسات قديمة.
- STUN/TURN قد يحتاج خدمة relay فقط للنقل، بدون فك تشفير المحتوى (E2E يبقى محفوظ).
- منع تصوير الشاشة/التسجيل غير مضمون بالكامل على كل أنظمة التشغيل، لكن يمكن تخفيف المخاطر.
- PIN من 6 أرقام مناسب للتجربة، لكنه يجب أن يُدعم دائماً بتحقق مفاتيح موثوقة من الاقتران الأول.

---

## 7) الخلاصة

هذا التعديل يحقق طلبك بدقة:
- **أول مرة لازم قرب فعلي ونفس النطاق** لتبادل الثقة عبر Bluetooth/LAN.
- **بعدها تواصل دائم عبر Wi‑Fi/الإنترنت من أي دولة** باستخدام P2P مشفر طرفي كامل.
- التنفيذ بالكامل ممكن بـ **Python** مع فصل واضح بين Core الأمني والواجهات متعددة المنصات.
